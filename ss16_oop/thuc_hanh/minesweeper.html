<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
            crossorigin="anonymous"></script>
    <link rel="stylesheet" href="minesweeper.css">
</head>
<body>
<div class="container">
    <h1>Game d√≤ m√¨n</h1>
    <div class="control" id="controls">
        <button class="btn btn-primary" id="resetMine">Ch∆°i l·∫°i</button>
        <span id="timer" class="btn btn-light">00:00</span>
        <button class="btn btn-secondary" id="settingMine">Thi·∫øt l·∫≠p</button>
<!--        <span id="timer2" class="btn btn-light" onclick="toggleUpdateTimeTwo()">00:00</span>-->
    </div>
    <div class="game">
        <canvas id="minesweeperCanvas" width="500" height="500"></canvas>
    </div>
</div>
<script>
    const canvas = document.getElementById('minesweeperCanvas');
    const ctx = canvas.getContext('2d');
    const sizeWidth = window.innerWidth;
    const sizeHeight = window.innerHeight;
    const size = Math.min(sizeWidth, sizeHeight) - 400;
    canvas.width = size;
    canvas.height = size;
    let colNumber = 8;
    let lolRows = colNumber;
    let cols = colNumber;
    let cellSize = size / colNumber;
    let mineCount = 8;
    let gameOver = false;

    let timer;
    let seconds = 0;

    function startTimer() {
        clearInterval(timer);
        updateTimerDisplay();
        timer = setInterval(updateTimer, 1000);
    }

    function updateTimer() {
        seconds++;
        updateTimerDisplay();
    }

    function updateTimerDisplay() {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        document.getElementById('timer').textContent =
            `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        //padStart ƒë·∫£m b·∫£o lu√¥n c√≥ 2 s·ªë , th√™m s·ªë 0 n·∫øu c·∫ßn;
    }

    function stopTimer() {
        clearInterval(timer);
    }


    const board = [];  //m·∫£ng l∆∞u th√¥ng tin t·ª´ng √¥(m√¨n xung quanh)
    let revealed = []; //m·∫£ng l∆∞u √¥ ƒë√£ m·ªü hay ch∆∞a
    let flags = [];    //m·∫£ng l∆∞u √¥ ƒë√£ c·∫Øm c·ªù nghi ng·ªù

    // t·∫°o b·∫£ng
    function initBoard() {
        seconds = 0;
        updateTimerDisplay();
        stopTimer();
        gameOver = false;
        for (let i = 0; i < lolRows; i++) {
            board[i] = [];
            revealed[i] = [];
            flags[i] = [];
            for (let j = 0; j < cols; j++) {
                board[i][j] = {mine: false, nearMines: 0};
                revealed[i][j] = false;
                flags[i][j] = false;
            }
        }
        //ƒë·∫∑t bom random
        let minesPlaced = 0;
        while (minesPlaced < mineCount) {
            const row = Math.floor(Math.random() * lolRows);
            const col = Math.floor(Math.random() * cols);
            if (!board[row][col].mine) {
                board[row][col].mine = true;
                minesPlaced++;
                updateNearCells(row, col);
            }
        }
    }

    function updateNearCells(row, col) {
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const newRow = row + i;
                const newCol = col + j;
                if (newRow >= 0 && newRow < lolRows && newCol >= 0 && newCol < cols && !(i === 0 && j === 0)) {
                    //ph·∫°m vi b·∫£ng h·ª£p l·ªá newRow v√† newCol                          !(√¥ ki·ªÉm tra)
                    board[newRow][newCol].nearMines++;
                }
            }
        }
    }

    //v·∫Ω l√™n html bƒÉng canvas
    function drawBoard() {
        for (let i = 0; i < lolRows; i++) {
            for (let j = 0; j < cols; j++) {
                const x = j * cellSize;
                const y = i * cellSize;
                if (revealed[i][j]) {
                    ctx.fillStyle = '#e0e0e0'//√¥ m·ªü r·ªìi
                } else {
                    ctx.fillStyle = '#8a8a8a'//√¥ ch∆∞a m·ªü
                }
                ctx.fillRect(x, y, cellSize, cellSize);
                ctx.strokeRect(x, y, cellSize, cellSize);

                if (revealed[i][j]) {
                    if (board[i][j].mine) { //√¥ ch·ª©a m√¨n
                        ctx.fillStyle = 'red';
                        ctx.font = `${cellSize * 0.6}px Arial`;
                        ctx.fillText('üí£', x + 15, y + 40);
                    } else if (board[i][j].nearMines > 0) { //kh√¥ng ch·ª©a m√¨n, ktra m√¨n l√¢n c·∫≠n
                        ctx.fillStyle = getNumberColor(board[i][j].nearMines)
                        ctx.font = `${cellSize * 0.45}px Arial`;
                        ctx.fillText(board[i][j].nearMines, x + 20, y + 35);
                    }
                } else if (flags[i][j]) {
                    ctx.fillStyle = 'blue'; //c·∫Øm c·ªù
                    ctx.font = `${cellSize * 0.6}px Arial`;
                    ctx.fillText('üö©', x + 15, y + 35);
                }
            }
        }
    }

    //m√†u √¥
    function getNumberColor(number) {
        const colors = ['#0000FF', '#008000', '#FF0000', '#000080', '#800000', '#008080', '#000000', '#808080'];
        return colors[number - 1] || '#000000';
    }

    // m·ªü c√°c √¥ l√¢n c·∫≠n n·∫øu kh√¥ng c√≥ bom xung quanh
    function revealCell(row, col) {
        if (row < 0 || row >= lolRows || col < 0 || col >= cols || revealed[row][col] || flags[row][col]) {
            return;
        }

        revealed[row][col] = true; //m·ªü √¥ n√†y

        if (board[row][col].nearMines === 0 && !board[row][col].mine) {
            //s·ªë m√¨n √¥ l√¢n c·∫≠n = 0               √¥ kh√¥ng c√≥ m√¨n
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    revealCell(row + i, col + j); // m·ªü h·∫øt 9 √¥
                }
            }
        }
    }

    function checkWin() {
        let cellsRevealed = 0;
        for (let i = 0; i < lolRows; i++) {
            for (let j = 0; j < cols; j++) {
                if (revealed[i][j]) {
                    cellsRevealed++;
                }
            }
        }

        if (cellsRevealed === lolRows * cols - mineCount) { // √¥ kh√¥ng c√≥ bom
            stopTimer();
            alert('You win!');
            gameOver = true;
        }
    }

    canvas.addEventListener('click', (event) => {
        if (seconds === 0) {
            startTimer();
        }
        //theo code w3school
        const rect = canvas.getBoundingClientRect();
        //getBoundingClientRect() d√πng ƒë·ªÉ l·∫•y k√≠ch th∆∞·ªõc v√† v·ªã tr√≠ c·ªßa ph·∫ßn t·ª≠
        const x = Math.floor((event.clientX - rect.left) / cellSize);//l·∫•y to·∫° ƒë·ªô x click chu·ªôt v√†o canvas tr·ª´ ƒëi v·ªã tr√≠ X
                                                                     // c·ªßa canvas
        const y = Math.floor((event.clientY - rect.top) / cellSize);//l·∫•y to·∫° ƒë·ªô y click chu·ªôt v√†o canvas tr·ª´ ƒëi v·ªã tr√≠ y
        // c·ªßa canvas
        if (gameOver) {
            return;
        }
        if (!revealed[y][x] && !flags[y][x]) {//n·∫øu √¥ ch∆∞a m·ªü v√† ch∆∞a c·∫Øm c·ªù
            if (board[y][x].mine) {
                revealCell(y, x);
                stopTimer();
                alert('Game Over!');
                gameOver = true;
            } else {
                revealCell(y, x); //y l√† h√†ng,x l√† c·ªôt
                checkWin();
            }
            drawBoard();
        }

    });

    canvas.addEventListener('contextmenu', (event) => { // chu·ªôt ph·∫£i
        event.preventDefault(); //k hi·ªán nh∆∞ khi b·∫•m chu·ªôt ph·∫£i l√™n web
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((event.clientX - rect.left) / cellSize);
        const y = Math.floor((event.clientY - rect.top) / cellSize);
        if (gameOver) {
            return;
        }
        if (!revealed[y][x]) {
            flags[y][x] = !flags[y][x]; //c·∫Øm c·ªù ho·∫∑c b·ªè c·ªù
            drawBoard();
        }
    });
    document.getElementById('resetMine').addEventListener('click', () => {

        initBoard();
        drawBoard();
    })
    document.getElementById('settingMine').addEventListener('click', () => {
        stopTimer();
        colNumber = parseInt(prompt(`nh·∫≠p s·ªë h√†ng/c·ªôt: `, colNumber)) || colNumber;
        lolRows = colNumber;
        cols = colNumber;
        mineCount = parseInt(prompt(`nh·∫≠p s·ªë bom mu·ªën r·∫£i: `, mineCount)) || mineCount;

        canvas.width = size;
        canvas.height = size;

        cellSize = size / colNumber;

        initBoard();
        drawBoard();
    })
    initBoard();
    drawBoard();

</script>
</body>
</html>
