<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <style>

        .control{
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        .game{
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
<div class="control" id="controls" >
    <button class="btn btn-secondary" id="resetMine">Ch∆°i l·∫°i</button>
</div>
<div class = "game">
    <canvas id="minesweeperCanvas" width="320" height="320"></canvas>
</div>
<script>
    const canvas = document.getElementById('minesweeperCanvas');
    const ctx = canvas.getContext('2d');
    let rows = 8;
    let cols = 8;
    const cellSize = 40;
    let mineCount = 10;

    const board = [];  //m·∫£ng l∆∞u th√¥ng tin t·ª´ng √¥(m√¨n xung quanh)
    let revealed = []; //m·∫£ng l∆∞u √¥ ƒë√£ m·ªü hay ch∆∞a
    let flags = [];    //m·∫£ng l∆∞u √¥ ƒë√£ c·∫Øm c·ªù nghi ng·ªù

    // t·∫°o b·∫£ng
    function initBoard() {
        for (let i = 0; i < rows; i++) {
            board[i] = [];
            revealed[i] = [];
            flags[i] = [];
            for (let j = 0; j < cols; j++) {
                board[i][j] = { mine: false, nearMines: 0 };
                revealed[i][j] = false;
                flags[i][j] = false;
            }
        }
        //ƒë·∫∑t bom random
        let minesPlaced = 0;
        while (minesPlaced < mineCount) {
            const row = Math.floor(Math.random() * rows);
            const col = Math.floor(Math.random() * cols);
            if (!board[row][col].mine) {
                board[row][col].mine = true;
                minesPlaced++;
                updateNearCells(row, col);
            }
        }
    }

    function updateNearCells(row, col) {
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const newRow = row + i;
                const newCol = col + j;
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !(i === 0 && j === 0)) {
                    //ph·∫°m vi b·∫£ng h·ª£p l·ªá newRow v√† newCol                          !(√¥ ki·ªÉm tra)
                    board[newRow][newCol].nearMines++;
                }
            }
        }
    }
    //v·∫Ω l√™n html bƒÉng canvas
    function drawBoard() {
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const x = j * cellSize;
                const y = i * cellSize;
                if(revealed[i][j]){
                    ctx.fillStyle = '#ddd'//√¥ m·ªü r·ªìi
                }else {
                    ctx.fillStyle = '#aaa'//√¥ ch∆∞a m·ªü
                }
                ctx.fillRect(x, y, cellSize, cellSize);
                ctx.strokeRect(x, y, cellSize, cellSize);

                if (revealed[i][j]) {
                    if (board[i][j].mine) { //√¥ ch·ª©a m√¨n
                        ctx.fillStyle = 'red';
                        ctx.fillText('üí£', x + 15, y + 30);
                    } else if (board[i][j].nearMines > 0) { //kh√¥ng ch·ª©a m√¨n, ktra m√¨n l√¢n c·∫≠n
                        ctx.fillStyle = 'black';
                        ctx.fillText(board[i][j].nearMines, x + 15, y + 30);
                    }
                } else if (flags[i][j]) {
                    ctx.fillStyle = 'blue'; //c·∫Øm c·ªù
                    ctx.fillText('üö©', x + 15, y + 30);
                }
            }
        }
    }

    // m·ªü c√°c √¥ l√¢n c·∫≠n n·∫øu kh√¥ng c√≥ bom xung quanh
    function revealCell(row, col) {
        if (row < 0 || row >= rows || col < 0 || col >= cols || revealed[row][col] || flags[row][col]) {
            return;
        }

        revealed[row][col] = true; //m·ªü √¥ n√†y

        if (board[row][col].nearMines === 0 && !board[row][col].mine) {
            //s·ªë m√¨n √¥ l√¢n c·∫≠n = 0               √¥ kh√¥ng c√≥ m√¨n
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    revealCell(row + i, col + j); // m·ªü h·∫øt 9 √¥
                }
            }
        }
    }

    function checkWin() {
        let cellsRevealed = 0;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                if (revealed[i][j]) {
                    cellsRevealed++;
                }
            }
        }

        if (cellsRevealed === rows * cols - mineCount) { // √¥ kh√¥ng c√≥ bom
            alert('You win!');
        }
    }
    let gameOver = false;
    canvas.addEventListener('click', (event) => {
        //theo code w3school
        const rect = canvas.getBoundingClientRect();
        //getBoundingClientRect() d√πng ƒë·ªÉ l·∫•y k√≠ch th∆∞·ªõc v√† v·ªã tr√≠ c·ªßa ph·∫ßn t·ª≠
        const x = Math.floor((event.clientX - rect.left) / cellSize);//l·∫•y to·∫° ƒë·ªô x click chu·ªôt v√†o canvas tr·ª´ ƒëi v·ªã tr√≠ X
                                                                     // c·ªßa canvas
        const y = Math.floor((event.clientY - rect.top) / cellSize);//l·∫•y to·∫° ƒë·ªô y click chu·ªôt v√†o canvas tr·ª´ ƒëi v·ªã tr√≠ y
                                                                     // c·ªßa canvas
        if (gameOver){
            return;
        }
        if (!revealed[y][x] && !flags[y][x]) {//n·∫øu √¥ ch∆∞a m·ªü v√† ch∆∞a c·∫Øm c·ªù
            if (board[y][x].mine) {
                revealCell(y, x);
                alert('Game Over!');
                gameOver = true;
            } else {
                revealCell(y, x); //y l√† h√†ng,x l√† c·ªôt
                checkWin();
            }
            drawBoard();
        }

    });

    canvas.addEventListener('contextmenu', (event) => { // chu·ªôt ph·∫£i
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((event.clientX - rect.left) / cellSize);
        const y = Math.floor((event.clientY - rect.top) / cellSize);
        if(gameOver){
            return;
        }
        if (!revealed[y][x]) {
            flags[y][x] = !flags[y][x]; //c·∫Øm c·ªù ho·∫∑c b·ªè c·ªù
            drawBoard();
        }
    });
    document.getElementById('resetMine').addEventListener('click',()=>{
        initBoard();
        drawBoard();
    })
    initBoard();
    drawBoard();
</script>

</body>
</html>